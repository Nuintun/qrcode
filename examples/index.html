<!DOCTYPE html>
<html>
  <head>
    <title>QRCode</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="./default.css" />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
  </head>
  <body>
    <div class="main">
      <ul class="tabs clearfix">
        <li class="selected">编码</li>
        <li>解码</li>
      </ul>
      <ul class="content clearfix">
        <li class="encode selected">
          <p>二维码内容：</p>
          <div><textarea id="encode-text">https://github.com/nuintun/qrcode</textarea></div>
          <p>
            <label>支持 FNC1：</label>
            <select id="hints-fnc1">
              <option value="NONE" selected>否</option>
              <option value="AIM">AIM</option>
              <option value="GS1">GS1</option>
            </select>
            <label class="indent">AIM 标识：</label>
            <input disabled id="aim-indicator" type="number" min="0" max="255" value="0" />
          </p>
          <p>
            <label>纠错等级：</label>
            <select id="encode-level">
              <option value="L">Level L (7%)</option>
              <option value="M" selected>Level M (15%)</option>
              <option value="Q">Level Q (25%)</option>
              <option value="H">Level H (30%)</option>
            </select>
            <label class="indent">编码方式：</label>
            <select id="encode-mode">
              <option value="Auto" selected>Auto</option>
              <option value="Alphanumeric">Alphanumeric</option>
              <option value="Byte">Byte</option>
              <option value="Hanzi">Hanzi</option>
              <option value="Kanji">Kanji</option>
              <option value="Numeric">Numeric</option>
            </select>
            <label class="indent">字符集：</label>
            <select id="encode-charset">
              <option value="ASCII">ASCII</option>
              <option value="UTF_8" selected>UTF-8</option>
              <option value="ISO_8859_1">ISO-8859-1</option>
            </select>
          </p>
          <p>
            <label>前景颜色：</label>
            <input id="gif-foreground" type="color" value="#000000" />
            <label class="indent">背景颜色：</label>
            <input id="gif-background" type="color" value="#ffffff" />
            <label class="indent">色块大小：</label>
            <input id="encode-msize" type="number" min="1" max="10" value="4" />
            <label class="indent">留白大小：</label>
            <input title="推荐设置为4倍色块大小" id="encode-margin" type="number" min="0" max="40" value="16" />
          </p>
          <p>
            <button id="encode-btn">编码</button>
          </p>
          <pre id="encode-result" class="encode-result hide"></pre>
        </li>
        <li class="decode">
          <p><label>二维码图片：</label><input type="file" accept="image/*" id="decode-file" /></p>
          <div>
            <canvas id="decode-canvas"></canvas>
          </div>
          <p>
            <button id="decode-btn">解码</button>
          </p>
          <pre id="decode-result" class="decode-result hide"></pre>
          <div>
            <canvas id="canvas1"></canvas>
          </div>
        </li>
      </ul>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.slim.min.js"></script>
    <script type="text/javascript" src="./qrcode.js"></script>
    <script type="text/javascript">
      // Tab 切换
      const nav = $('.tabs li');
      const content = $('.content li');

      nav.on('click', function () {
        const target = $(this);

        nav.removeClass('selected');

        target.addClass('selected');

        content.removeClass('selected').eq(target.index()).addClass('selected');
      });

      const hintsFNC1 = $('#hints-fnc1');
      const encodeMode = $('#encode-mode');
      const encodeText = $('#encode-text');
      const encodeLevel = $('#encode-level');
      const encodeMSize = $('#encode-msize');
      const aimIndicator = $('#aim-indicator');
      const encodeMargin = $('#encode-margin');
      const encodeResult = $('#encode-result');
      const encodeCharset = $('#encode-charset');
      const gifBackground = $('#gif-background');
      const gifForeground = $('#gif-foreground');

      hintsFNC1.on('change', function () {
        aimIndicator.prop('disabled', hintsFNC1.val() !== 'AIM');
      });

      encodeMode.on('change', function () {
        const mode = encodeMode.val();

        encodeCharset.prop('disabled', mode !== 'Auto' && mode !== 'Byte');
      });

      function getFNC1Hint() {
        switch (hintsFNC1.val()) {
          case 'GS1':
            return ['GS1'];
          case 'AIM':
            return ['AIM', +aimIndicator.val()];
        }
      }

      function hex2rgb(hex) {
        hex = parseInt(hex.replace('#', '0x'));

        return [(hex >> 16) & 0xff, (hex >> 8) & 0xff, hex & 0xff];
      }

      const NUMERIC_RE = /^\d+$/;
      const ALPHANUMERIC_RE = /^[0-9A-Z$%*+-./: ]+$/;

      function chooseBestMode(mode, data) {
        if (mode === 'Auto') {
          if (NUMERIC_RE.test(data)) {
            return new QRCode.Numeric(data);
          } else if (ALPHANUMERIC_RE.test(data)) {
            return new QRCode.Alphanumeric(data);
          }

          const hanzi = new QRCode.Hanzi(data);

          try {
            hanzi.encode();

            return hanzi;
          } catch {
            // 跳过错误
          }

          const kanji = new QRCode.Kanji(data);

          try {
            kanji.encode();

            return kanji;
          } catch {
            // 跳过错误
          }

          // 回退字节模式
          mode = 'Byte';
        }

        return new QRCode[mode](data, QRCode.Charset[encodeCharset.val()]);
      }

      // 生成二维码
      $('#encode-btn').on('click', function () {
        const data = encodeText.val();
        const mode = encodeMode.val();
        const level = encodeLevel.val();
        const margin = parseInt(encodeMargin.val());
        const moduleSize = parseInt(encodeMSize.val());
        const background = hex2rgb(gifBackground.val());
        const foreground = hex2rgb(gifForeground.val());

        encodeResult.removeClass('hide');

        try {
          const encoder = new QRCode.Encoder({
            level,
            version: 'auto',
            hints: { fnc1: getFNC1Hint() }
          });

          console.dir(encoder);
          console.dir(QRCode.Charset);

          const segment = chooseBestMode(mode, data);

          console.time('encode');
          const qrcode = encoder.encode(chooseBestMode(mode, data));
          console.timeEnd('encode');

          console.dir(qrcode);

          console.time('toDataURL');
          const url = qrcode.toDataURL(moduleSize, { margin, foreground, background });
          console.timeEnd('toDataURL');

          encodeResult.html(`<img src="${url}" />`);

          const decoder = new QRCode.Decoder();

          const matrix = qrcode.matrix;
          const size = matrix.size;
          const bitMatrix = new QRCode.BitMatrix(size, size);
          const bitMatrixMirror = new QRCode.BitMatrix(size, size);

          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              if (matrix.get(x, y) === 1) {
                bitMatrix.set(x, y);
                bitMatrixMirror.set(y, x);
              }
            }
          }

          console.time('decode');
          console.dir(decoder.decode(bitMatrix));
          console.timeEnd('decode');
          console.time('decode mirror');
          console.dir(decoder.decode(bitMatrixMirror));
          console.timeEnd('decode mirror');
        } catch (error) {
          encodeResult.html(`<span class="error">${error.message}</span>`);

          console.error(error);
        }
      });

      let hasImage = false;
      let imageData = null;

      const canvas1 = $('#canvas1')[0];
      const canvas = $('#decode-canvas')[0];
      const decodeResult = $('#decode-result');
      const context = canvas.getContext('2d', { willReadFrequently: true });

      function resetDecoder() {
        hasImage = false;
        imageData = null;
      }

      function drawImage(src) {
        const img = new Image();

        img.crossOrigin = 'anonymous';

        img.onload = function () {
          const width = img.width;
          const height = img.height;
          const actualWidth = Math.min(960, width);
          const actualHeight = height * (actualWidth / width);

          hasImage = true;
          canvas.width = actualWidth;
          canvas.height = actualHeight;

          context.drawImage(img, 0, 0, width, height, 0, 0, actualWidth, actualHeight);

          imageData = context.getImageData(0, 0, actualWidth, actualHeight);
        };

        img.src = src;
      }

      // 二维码加载
      $('#decode-file').on('change', function (e) {
        const file = e.target.files[0];

        if (file) {
          resetDecoder();

          const reader = new FileReader();

          reader.onload = function (e) {
            drawImage(e.target.result);
          };

          reader.readAsDataURL(file);
        }
      });

      function getImageData() {
        imageData && context.putImageData(imageData, 0, 0);

        return imageData || context.getImageData(0, 0, canvas.width, canvas.height);
      }

      function markFinderPattern({ x, y, moduleSize }, color) {
        context.fillStyle = color;

        context.beginPath();
        context.arc(x, y, moduleSize * 0.75, 0, 2 * Math.PI);
        context.fill();
      }

      function drawDot(context, x, y, dotColor) {
        context.save();
        context.strokeStyle = dotColor;
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo(x + 1, y + 1);
        context.closePath();
        context.stroke();
        context.restore();
      }

      function drawMatrix(canvas, matrix, moduleSize = 1) {
        const { width, height } = matrix;
        const actualWidth = width * moduleSize;
        const actualHeight = height * moduleSize;
        const canvasContext = canvas.getContext('2d');
        const imageData = canvasContext.createImageData(actualWidth, actualHeight);

        canvas.width = actualWidth;
        canvas.height = actualHeight;

        const { data } = imageData;

        for (let y = 0; y < actualHeight; y++) {
          for (let x = 0; x < actualWidth; x++) {
            let offset = (y * actualWidth + x) * 4;

            const offsetX = (x / moduleSize) | 0;
            const offsetY = (y / moduleSize) | 0;
            const color = matrix.get(offsetX, offsetY) ? 0 : 255;

            data[offset++] = color;
            data[offset++] = color;
            data[offset++] = color;
            data[offset] = 255;
          }
        }

        canvasContext.putImageData(imageData, 0, 0);
      }

      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      function calcTriangleArea(point1, point2, point3) {
        return Math.abs(
          (point1.x * point2.y +
            point2.x * point3.y +
            point3.x * point1.y -
            point2.x * point1.y -
            point3.x * point2.y -
            point1.x * point3.y) /
            2.0
        );
      }
      function isPointInQuadrangle(point, topLeft, topRight, bottomRight, bottomLeft) {
        return (
          calcTriangleArea(topLeft, topRight, point) +
            calcTriangleArea(topRight, bottomRight, point) +
            calcTriangleArea(bottomRight, bottomLeft, point) +
            calcTriangleArea(bottomLeft, topLeft, point) ===
          calcTriangleArea(topLeft, topRight, bottomRight) + calcTriangleArea(bottomRight, bottomLeft, topLeft)
        );
      }

      const ctx = canvas1.getContext('2d');

      const a = new Point(25, 15);
      const b = new Point(75, 25);
      const c = new Point(75, 100);
      const d = new Point(25, 75);
      const p = new Point(50, 50);

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.lineTo(c.x, c.y);
      ctx.lineTo(d.x, d.y);
      ctx.lineTo(a.x, a.y);
      ctx.stroke();

      drawDot(ctx, p.x, p.y, '#ff0000');

      console.log(isPointInQuadrangle(p, a, b, c, d));

      $('#decode-btn').on('click', function () {
        decodeResult.removeClass('hide');

        if (!hasImage) {
          return decodeResult.html(`<span class="error">请选择二维码图片</span>`);
        }

        const errors = [];
        const success = [];
        const alignments = [];
        const imageData = getImageData();
        const { width, height } = imageData;
        const decoder = new QRCode.Decoder();
        const matrix = QRCode.binarizer(imageData);
        const detector = new QRCode.Detector();
        const detected = detector.detect(matrix);

        drawMatrix(canvas1, matrix, 1);

        // const x = QRCode.extract(matrix);

        // console.dir(x);

        // for (const { matrix: image } of x) {
        //   try {
        //     const decoded = decoder.decode(image);

        //     console.dir(image);
        //     console.dir(decoded.content);
        //   } catch (error) {
        //     // console.error(error);
        //   }
        // }

        console.dir(detected);

        if (detected.length > 0) {
          for (const { matrix, finder, alignment } of detected) {
            console.dir(matrix);
            console.dir(finder);
            console.dir(alignment);

            if (alignment) {
              alignments.push(alignment);
            }

            try {
              const decoded = decoder.decode(matrix);
              const { content } = decoded;

              if (content) {
                decodeResult.html(content);
                success.push(finder);
                console.dir(decoded);
                console.dir(content);
              } else {
                errors.push(finder);
              }
            } catch (error) {
              // 解码失败，跳过
              errors.push(finder);
            }
          }
        }

        for (const { topLeft, topRight, bottomLeft } of errors) {
          markFinderPattern(topLeft, '#ff0000');
          markFinderPattern(topRight, '#00ff00');
          markFinderPattern(bottomLeft, '#0000ff');
        }

        if (success.length > 0) {
          for (const { topLeft, topRight, bottomLeft } of success) {
            markFinderPattern(topLeft, '#00ff00');
            markFinderPattern(topRight, '#00ff00');
            markFinderPattern(bottomLeft, '#00ff00');
          }
        } else {
          decodeResult.html(`<span class="error">未发现二维码</span>`);
        }

        for (const alignment of alignments) {
          markFinderPattern(alignment, '#ff00ff');
        }
      });

      /https?:/i.test(location.protocol) && drawImage('./qrcode.jpg');
    </script>
  </body>
</html>
